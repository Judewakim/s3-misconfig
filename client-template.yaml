AWSTemplateFormatVersion: '2010-09-09'
Description: Client-side template for WakimWorks S3 Security Scanner - Deploys IAM role for cross-account scanning and registers with seller.

Parameters:
  UserEmail:
    Type: String
    Description: Email address to receive scan results.
    AllowedPattern: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
    ConstraintDescription: Must be a valid email address.
  ExcludeBuckets:
    Type: String
    Description: Comma-separated list of S3 bucket names to exclude (e.g., bucket1,bucket2).
    Default: ""
  InvocationMode:
    Type: String
    Description: "Mode: 'scanning_only' or 'scanning_and_autoremediation'."
    Default: "scanning_only"
    AllowedValues:
      - "scanning_only"
      - "scanning_and_autoremediation"

Conditions:
  IsAutoRemediation: !Equals [!Ref InvocationMode, "scanning_and_autoremediation"]

Resources:
  # IAM Role for ExternalId Generator Lambda
  ExternalIdGeneratorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole  # Logs only
  
  # Lambda to Generate ExternalId (Email + Timestamp)
  ExternalIdGeneratorLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: ExternalIdGenerator
      Handler: index.handler
      Runtime: python3.12
      Role: !GetAtt ExternalIdGeneratorRole.Arn
      Code:
        ZipFile: |
          import json
          import datetime
          import cfnresponse

          def handler(event, context):
              try:
                  if event['RequestType'] == 'Create':
                      email = event['ResourceProperties']['UserEmail']
                      timestamp = datetime.datetime.utcnow().isoformat()  # ISO 8601, e.g., 2025-10-18T23:14:00.123456
                      external_id = f"{email}_{timestamp}"  # Combine email + timestamp
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {'ExternalId': external_id})
                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})  # No-op for update/delete
              except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})
      Timeout: 10
      MemorySize: 128

  # Custom Resource to Generate ExternalId
  ExternalIdCustomResource:
    Type: Custom::ExternalIdGenerator
    Properties:
      ServiceToken: !GetAtt ExternalIdGeneratorLambda.Arn
      UserEmail: !Ref UserEmail  # Pass email to generate ExternalId

  # IAM Role for Seller Lambda to Assume
  ScannerAssumeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: S3SecurityScannerClientRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:aws:iam::390488375643:role/S3SecurityScannerLambdaRole"  # Hardcoded seller account ID
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                sts:ExternalId: !GetAtt ExternalIdCustomResource.ExternalId  # Use generated ExternalId
      Policies:
        - PolicyName: S3ScanAndRemediatePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListAllMyBuckets
                  - s3:GetBucketAcl
                  - s3:GetBucketPolicy
                  - s3:GetPublicAccessBlock
                  - s3:GetBucketEncryption
                  - s3:GetBucketVersioning  # Future-proof
                  - s3:GetObjectLockConfiguration  # Future-proof
                  - s3:GetBucketLogging  # Future-proof
                  - s3:GetReplicationConfiguration  # Future-proof
                  - s3:GetBucketPolicyStatus  # Enhanced
                Resource: '*'
              - Effect: Allow
                Action:
                  - s3:PutPublicAccessBlock
                  - s3:PutBucketAcl
                  - s3:PutBucketPolicy
                  - s3:PutBucketEncryption
                  - s3:PutBucketVersioning  # Future-proof
                  - s3:PutObjectLockConfiguration  # Future-proof
                  - s3:PutBucketLogging  # Future-proof
                  - s3:PutReplicationConfiguration  # Future-proof
                Resource: '*'
                Condition:
                  Bool:
                    aws:SecureTransport: 'true'  # Enforce HTTPS

  # IAM Role for Registration Lambda
  RegistrationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: S3ScannerRegistrationLambdaRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: RegistrationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # - Effect: Allow
              #   Action:
              #     - dynamodb:PutItem
              #     - dynamodb:DeleteItem
              #   Resource: arn:aws:dynamodb:us-east-1:390488375643:table/S3ScannerClientMetadata
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource:
                - arn:aws:sqs:us-east-1:390488375643:S3ScannerRegistrationQueue
                - arn:aws:sqs:us-east-1:390488375643:S3ScannerQueue
                
  # Lightweight Lambda for Registration
  RegistrationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: S3ScannerRegistrationLambda
      Handler: index.handler
      Runtime: python3.12
      Role: !GetAtt RegistrationLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import logging

          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)

          def handler(event, context):
              try:
                  sqs = boto3.client('sqs', region_name='us-east-1')
                  request_type = event['RequestType']
                  props = event['ResourceProperties']
                  required_props = ['RoleArn', 'Email', 'InvocationMode', 'ExcludeBuckets', 'ExternalId', 'SqsQueueUrl']
                  missing_props = [p for p in required_props if p not in props]
                  if missing_props:
                      raise ValueError(f"Missing required properties: {', '.join(missing_props)}")
                  account_id = context.invoked_function_arn.split(':')[4]
                  payload = {
                      'AccountId': account_id,
                      'RoleArn': props['RoleArn'],
                      'Email': props['Email'],
                      'InvocationMode': props['InvocationMode'],
                      'ExcludeBuckets': props['ExcludeBuckets'],
                      'ExternalId': props['ExternalId'],
                      'Action': 'register' if request_type in ['Create', 'Update'] else 'deregister'
                  }
                  # Send to both queues
                  sqs.send_message(
                      QueueUrl=props['SqsQueueUrl'],  # RegistrationQueue
                      MessageBody=json.dumps(payload)
                  )
                  sqs.send_message(
                      QueueUrl='https://sqs.us-east-1.amazonaws.com/390488375643/S3ScannerQueue',
                      MessageBody=json.dumps(payload)
                  )
                  logger.info(f"Sent SQS message for AccountId={account_id}, Action={payload['Action']}")
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Status': payload['Action'].capitalize()})
              except Exception as e:
                  logger.error(f"Error processing {request_type}: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})
      Timeout: 30
      MemorySize: 128

  # Custom Resource to Trigger Registration
  RegistrationCustomResource:
    Type: Custom::Registration
    Properties:
      ServiceToken: !GetAtt RegistrationLambda.Arn
      RoleArn: !GetAtt ScannerAssumeRole.Arn
      AccountId: !Ref AWS::AccountId
      Email: !Ref UserEmail
      InvocationMode: !Ref InvocationMode
      ExcludeBuckets: !Ref ExcludeBuckets
      ExternalId: !GetAtt ExternalIdCustomResource.ExternalId  # Pass generated ExternalId
      SqsQueueUrl: !Sub "https://sqs.us-east-1.amazonaws.com/390488375643/S3ScannerRegistrationQueue"  # Hardcode or provide via docs

  # ScannerCustomResource
  ScannerCustomResource:
    Type: Custom::ScannerTrigger
    Properties:
      ServiceToken: !GetAtt RegistrationLambda.Arn
      RoleArn: !GetAtt ScannerAssumeRole.Arn
      AccountId: !Ref AWS::AccountId
      Email: !Ref UserEmail
      InvocationMode: !Ref InvocationMode
      ExcludeBuckets: !Ref ExcludeBuckets
      ExternalId: !GetAtt ExternalIdCustomResource.ExternalId
      SqsQueueUrl: !Sub "https://sqs.us-east-1.amazonaws.com/390488375643/S3ScannerQueue"

Outputs:
  ScannerRoleArn:
    Description: ARN of the assumeable role for scanning.
    Value: !GetAtt ScannerAssumeRole.Arn
  ExternalId:
    Description: Generated ExternalId for assume-role.
    Value: !GetAtt ExternalIdCustomResource.ExternalId